"use strict";(self.webpackChunkqbenben_blog=self.webpackChunkqbenben_blog||[]).push([[263],{4298:(e,o,t)=>{t.r(o),t.d(o,{data:()=>i});const i={key:"v-6a1935fb",path:"/post/2022/02/27/cz-git/",title:"cz-git 友好型 commitizen 的适配器",lang:"zh-CN",frontmatter:{layout:"Post",title:"cz-git 友好型 commitizen 的适配器",description:"我的开发心路历程 | cz-git 是一款commitizen adapter(适配器)，拥有高度自定义，针对gitee commit issue支持，支持emoji的commit，与commitlint配合检查，可以有效减少commit错误，达到commit标准化规范，可针对monorepo前端工程化工具。",subtitle:"为什么会开发 cz-git",author:"qbenben",date:"2022-02-27T00:00:00.000Z",useHeaderImage:!0,headerImage:"https://tva3.sinaimg.cn/large/6ccee0e1gy1gztgn21x8zj21uc0x648q.jpg",headerMask:"rgba(95, 96, 99, .5)",catalog:!0,permalinkPattern:"/post/:year/:month/:day/:slug/",tags:["前端","前端工程化"]},excerpt:"<p>我的开发心路历程</p>\n",headers:[{level:2,title:"前言",slug:"前言",children:[]},{level:2,title:"概念",slug:"概念",children:[]},{level:2,title:"为什么不使用",slug:"为什么不使用",children:[{level:3,title:"cz-conventional-changelog",slug:"cz-conventional-changelog",children:[]},{level:3,title:"cz-customizable",slug:"cz-customizable",children:[]}]},{level:2,title:"解决痛点以及心路历程",slug:"解决痛点以及心路历程",children:[]},{level:2,title:"写在最后",slug:"写在最后",children:[]}],git:{updatedTime:1646581455e3,contributors:[{name:"Zhengqbbb",email:"1074059947@qq.com",commits:8}]},readingTime:{minutes:7,words:1633},filePathRelative:"posts/cz-git.md"}},7238:(e,o,t)=>{t.r(o),t.d(o,{default:()=>c});const i=(0,t(6252).uE)('<p>我的开发心路历程</p><br><p align="center"><a target="_blank" href="https://github.com/Zhengqbbb/cz-git">Github</a> · <a target="_blank" href="https://cz-git.qbenben.com">中文文档</a></p><p><img src="https://user-images.githubusercontent.com/40693636/154906217-e0b1c5d0-9294-4072-8082-c0cdd9392023.gif" alt="demo-gif"></p><hr><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><blockquote><p>本文不会讲述 cz-git 的使用方法，主要讲述我在开发这款适配器中的心路历程。</p></blockquote><ul><li>随着多人开发团队推进着前端工程化的不断发展，团队规范与项目系统化配套工具链条也在不断诞生。</li><li>从 <code>lerna</code> 或到最近兴起的 <code>pnpm</code> 管理 <code>monoreo workspace</code>。</li><li><code>eslint</code> 配合 <code>pretter</code> 确保团队代码格式统一性。</li><li><code>commitizen</code> 配合 <code>commitlint</code> 与 <code>lint-staged</code> 与 <code>husky</code> 之间的配合，把关最后提交代码质量与 commit 信息规范。</li><li>再到利用 <code>circleci</code>, <code>github action</code> 或 <code>gitee go</code> 进行CI/CD(持续集成、持续交付和持续部署)。</li></ul><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p><strong>什么是 commitlint</strong> : git commit 时对于 commit message 进行规范检查的工具，保证团队的一致性。</p><p><strong>什么是 commitizen</strong> : 基于Node.js的 <code>git commit</code> 命令行工具，辅助生成标准化规范化的 commit message。</p><p><strong>什么是 adapter(适配器)</strong> : 更换 commitizen 命令行工具的<strong>交互方式</strong>插件。</p><hr><p><strong>cz-git 有什么特点</strong></p><ul><li>友好型命令行工具，<strong>“懒字优先”</strong> ！支持在命令行搜索和选择，减少拼写错误。</li><li><strong>高度自定义</strong>, 但输出格式遵循标准的 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits" target="_blank" rel="noopener noreferrer">Angular commit</a> 规范。</li><li>更好维护 monorepo 工程化项目 与 <strong>commitlint</strong> 配合给予命令行的相关校验信息。</li><li>更好的与issue链接，尤其 <strong>gitee</strong> | ✅ 支持在 commit 中添加 <strong>emoji</strong>。</li></ul><h2 id="为什么不使用" tabindex="-1"><a class="header-anchor" href="#为什么不使用" aria-hidden="true">#</a> 为什么不使用</h2><h3 id="cz-conventional-changelog" tabindex="-1"><a class="header-anchor" href="#cz-conventional-changelog" aria-hidden="true">#</a> cz-conventional-changelog</h3><blockquote><p>commitizen 官方的适配器(起初所使用)</p></blockquote><ul><li>添加配置需要写在 <code>package.json</code> 中，并且可支持的自定义配置太少</li><li>交互方式并不友好，重复性输入的东西太多</li></ul><h3 id="cz-customizable" tabindex="-1"><a class="header-anchor" href="#cz-customizable" aria-hidden="true">#</a> cz-customizable</h3><blockquote><p>可支持自定义的适配器(cz-git 起初参照对象)</p></blockquote><ul><li>随着使用 <code>monoreo</code> ，我开始寻求更好的适配器来解决我<strong>需要重复输入 <code>scopes</code> 的问题，但不久后我发现这并不是我想要的</strong>。</li><li>随着我的 packages 不断增大，<strong>仅支持选择的交互方式体验会很难受</strong>，需要从上到下不断寻找。</li><li>配置文件问题，我需要额外增加 <code>.cz-config.js</code> 在我的项目中，如此一来我配合 <code>commitlint</code> 需要配置两个地方，这为什么不能联动配合获取。</li><li>支持的自定义配置还是太少，比如我想要 跳过选项 置于顶部，以配合团队 commit 整体习惯等，这些大大小小会很影响使用体验。</li></ul><h2 id="解决痛点以及心路历程" tabindex="-1"><a class="header-anchor" href="#解决痛点以及心路历程" aria-hidden="true">#</a> 解决痛点以及心路历程</h2><ol><li><strong>工程师追求的极致 ”懒“</strong> ：作为开发工程师的我们平时会利用我们的习惯结合我们的技术，去想办法处理好重复性的工作或者恶心难受的事情，这也是我所<strong>追求向往</strong>的。</li><li><strong>什么是友好交互型命令行工具</strong> ：命令行工具的设计一定要具有引导性，要有很好的支持交互型的<strong>complate</strong>。<br><br>比如说我为我的 <code>monorepo</code> ui库中 table 添加了测试。我在 commit 的时候<strong>脑海里第一时间浮现</strong>是 test table。但如果像之前适配器要我去选择大量选项，就会很烦，失去了使用命令行工具的便利性，并且还有拼写出错的风险。<br>我想要的是 只用输入 <code>te</code> 回车输出<code>test</code>, <code>ta</code> 回车输出 <code>table</code>，这样用起来才舒服。<br><br></li><li><strong>如何支持好高度自定义以及配置</strong> ：这个工具的高度自定义肯定是结合<strong>团队习惯</strong>自定义设计。<br>比如大多数情况我们的 commit <code>scopes</code>(范围) 是为空直接跳过，那么我们的第一项应该是 <code>empty</code>。如果是团队高度规范了规则的输出，那么我们的 <code>empty</code> 应该不显示或者置于底部。</li><li><strong>最后也是我发现至关重要的一点</strong> ：使用 <mark>gitee</mark> 进行开发管理中，利用 commit message可以改变issue状态。<a href="https://gitee.com/help/articles/4141#article-header2" target="_blank" rel="noopener noreferrer">Commit 关联Issue</a> <br><strong>通过设置任务状态指令，即起issue状态变更的别名，通过选择别名和输入issue号，可以很好的关联并管理issue</strong><br> 再配合命令行中所支持搜索与选择，就会达到很好的体验。<br> 比如像我就经常会等到开发完成后才到<mark>网页</mark>将 issue 待进行转为待完成再进行流程，没有很好的关联代码提交留痕。现在我只需要在创建分支的时候分支名携带issue number。结合我设置<code>finish</code>为 将任务转为待完成，这样我就能在 commit 的时候更改issue状态并留痕代码提交记录方便回溯。</li></ol><br><br><p>基于以上的初心我开发了 <a href="https://github.com/Zhengqbbb/cz-git" target="_blank" rel="noopener noreferrer">cz-git</a>，欢迎大家前来使用。如果觉得不错的可以给个小星星~</p><h2 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后" aria-hidden="true">#</a> 写在最后</h2><p>你要问我这达到你的目的了吗 ？ 其实我还没有</p><ol><li>基于 <code>Node.js</code> 来启动的命令行，光是启动 Node.js 就慢了。但如果你如果你只接触了<code>Node.js</code> 的命令行工具应该没有感觉，但对于我来说经常接触命令行生态的人而言会很难受。这种感觉就像是使用了 <code>144 Hz</code> 的显示器屏幕回不到 <code>60 Hz</code> 的感觉。</li><li><strong>依赖 Node.js 环境</strong>，无法做到零依赖的兼容性支持，简单来说就是格局小了。比方你要给其他部门的安利 <code>cz-git</code>，你需要告诉他，需要安装Node.js再...才能使用。</li><li>拿 <code>Go，Rust</code> 来制作 <code>commitizen</code> ？ 答案是不会，体积和速度我还是无法接受<br> 引用 <a href="https://github.com/skywind3000/z.lua" target="_blank" rel="noopener noreferrer">zlua</a> 作者的一句话: (但也不是Lua，需要依赖Lua环境)</li></ol><blockquote><p>很多命令行工具 go/rust 写成，动不动就 2MB / 3MB，他们都还没有完成加载,lua 脚本可能都运行完了</p></blockquote><p>挖坑，待我继续深耕，开发完成后再来揭晓</p><hr><br><br><blockquote><p>I just try my best to make thing well, Could you give a <a href="https://github.com/Zhengqbbb/cz-git" target="_blank" rel="noopener noreferrer">star ⭐</a>.<br> 我是 Qbenben，一个爱折腾在沉浸在代码世界打怪升级的深圳小靓仔，感谢您的阅读。<a href="https://github.com/Zhengqbbb" target="_blank" rel="noopener noreferrer">Github</a> · <a href="https://www.qbenben.com/" target="_blank" rel="noopener noreferrer">Blog</a></p></blockquote>',36),r={},c=(0,t(3744).Z)(r,[["render",function(e,o){return i}]])}}]);