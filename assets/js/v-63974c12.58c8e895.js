"use strict";(self.webpackChunkqbenben_blog=self.webpackChunkqbenben_blog||[]).push([[85],{9900:(t,e,a)=>{a.r(e),a.d(e,{data:()=>o});const o={key:"v-63974c12",path:"/post/2022/01/11/husky/",title:"新版 husky 配置与Git Hooks剖析",lang:"zh-CN",frontmatter:{layout:"Post",title:"新版 husky 配置与Git Hooks剖析",description:"husky 配置与Git Hooks剖析，前端工程化 —— husky | Qbenben blog. Record my life | 在代码世界里打怪升级的小靓仔",subtitle:"前端工程化 —— husky",author:"qbenben",date:"2022-01-11T00:00:00.000Z",useHeaderImage:!0,headerImage:"https://tva3.sinaimg.cn/large/6ccee0e1gy1gyfzev5ju3j21kw0y6k0g.jpg",headerMask:"rgba(40, 57, 101, .4)",catalog:!0,permalinkPattern:"/post/:year/:month/:day/:slug/",tags:["前端","前端工程化"]},excerpt:"<p>分享近期配置 husky 的一些心得</p>\n",headers:[{level:2,title:"(4.*) 旧版玩法",slug:"_4-旧版玩法",children:[{level:4,title:"1. 下载依赖",slug:"_1-下载依赖",children:[]},{level:4,title:"2. 配置",slug:"_2-配置",children:[]}]},{level:2,title:"(7.*) 新版玩法",slug:"_7-新版玩法",children:[{level:4,title:"1. 下载依赖",slug:"_1-下载依赖-1",children:[]},{level:4,title:"2. 配置",slug:"_2-配置-1",children:[]}]},{level:2,title:"新版剖析",slug:"新版剖析",children:[{level:4,title:"为什么抛弃传统js的写法",slug:"为什么抛弃传统js的写法",children:[]},{level:4,title:"新版是什么原理",slug:"新版是什么原理",children:[]},{level:4,title:"总结",slug:"总结",children:[]}]},{level:2,title:"旧版迁移新版",slug:"旧版迁移新版",children:[]},{level:2,title:"Git Hooks",slug:"git-hooks",children:[]}],git:{updatedTime:1645680843e3,contributors:[{name:"Zhengqbbb",email:"1074059947@qq.com",commits:10}]},readingTime:{minutes:8,words:1651},filePathRelative:"posts/husky.md"}},9394:(t,e,a)=>{a.r(e),a.d(e,{default:()=>u});var o=a(6252);const s=(0,o.uE)('<p>分享近期配置 husky 的一些心得</p><h1 id="husky" tabindex="-1"><a class="header-anchor" href="#husky" aria-hidden="true">#</a> husky</h1><br><p align="center"><a target="_blank" href="https://github.com/typicode/husky">Github</a> · <a target="_blank" href="https://typicode.github.io/husky/#/">文档</a></p><hr><p>husky 是前端工程化不可缺少的工具，它支持添加项目的 git hooks(可以理解当我们使用 git 命令操作时会触发的钩子事件)，如此一来我们就能在提交代码时:</p><p>配合 <a href="https://github.com/conventional-changelog/commitlint" target="_blank" rel="noopener noreferrer">commitlint</a> | <a href="https://github.com/okonet/lint-staged" target="_blank" rel="noopener noreferrer">lint-staged</a> &amp; ESlint &amp; Stylelint，对<mark>提交信息</mark>进行检查 | 运行测试 | 检查代码格式与是否报错。</p><br> 我还记得在我实习的时候，我老大就经常会进行前端工程化的工作，将我们几个实习生的代码规范和开发流程严格把控，时间长了对这几个前端工程化工具慢慢就会熟悉。这恰恰是一个开发团队需要的开发规范。这几天我也需要搭建一个新的项目但是发现 husky 的配置和原来有很大的不一样。 <h2 id="_4-旧版玩法" tabindex="-1"><a class="header-anchor" href="#_4-旧版玩法" aria-hidden="true">#</a> (4.*) 旧版玩法</h2><hr><h4 id="_1-下载依赖" tabindex="-1"><a class="header-anchor" href="#_1-下载依赖" aria-hidden="true">#</a> 1. 下载依赖</h4>',12),n=(0,o._)("div",{class:"language-bash ext-sh"},[(0,o._)("pre",{class:"language-bash"},[(0,o._)("code",null,[(0,o._)("span",{class:"token function"},"npm"),(0,o.Uk)(),(0,o._)("span",{class:"token function"},"install"),(0,o.Uk)(" -D husky@^4.3.0\n")])])],-1),c=(0,o._)("div",{class:"language-bash ext-sh"},[(0,o._)("pre",{class:"language-bash"},[(0,o._)("code",null,[(0,o._)("span",{class:"token function"},"yarn"),(0,o.Uk)(),(0,o._)("span",{class:"token function"},"add"),(0,o.Uk)(" -D husky@^4.3.0\n")])])],-1),i=(0,o.uE)('<h4 id="_2-配置" tabindex="-1"><a class="header-anchor" href="#_2-配置" aria-hidden="true">#</a> 2. 配置</h4><blockquote><p>在 <mark>package.json</mark> 中配置 <code>husky</code> 属性</p></blockquote><div class="language-json ext-json"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;husky&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;hooks&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token property">&quot;pre-push&quot;</span><span class="token operator">:</span> <span class="token string">&quot;npm run test&quot;</span><span class="token punctuation">,</span>\n      <span class="token property">&quot;commit-msg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;commitlint --config -E HUSKY_GIT_PARAMS&quot;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ul><li>这样在你执行 <code>git commit</code> 的时候就会自动执行 <code>commitlint</code> 命令。<strong>即</strong>把你的commit信息赋值给 <code>HUSKY_GIT_PARAMS</code> 作为参数传入<code>commitlint</code>命令进行校验。</li><li>这里可以看出旧版主要是利用 <code>package.json</code> 进行git钩子信息获取。</li></ul><h2 id="_7-新版玩法" tabindex="-1"><a class="header-anchor" href="#_7-新版玩法" aria-hidden="true">#</a> (7.*) 新版玩法</h2><hr><h4 id="_1-下载依赖-1" tabindex="-1"><a class="header-anchor" href="#_1-下载依赖-1" aria-hidden="true">#</a> 1. 下载依赖</h4>',7),d=(0,o._)("div",{class:"language-bash ext-sh"},[(0,o._)("pre",{class:"language-bash"},[(0,o._)("code",null,[(0,o._)("span",{class:"token function"},"npm"),(0,o.Uk)(),(0,o._)("span",{class:"token function"},"install"),(0,o.Uk)(" -D husky\n")])])],-1),r=(0,o._)("div",{class:"language-bash ext-sh"},[(0,o._)("pre",{class:"language-bash"},[(0,o._)("code",null,[(0,o._)("span",{class:"token function"},"yarn"),(0,o.Uk)(),(0,o._)("span",{class:"token function"},"add"),(0,o.Uk)(" -D husky\n")])])],-1),l=(0,o.uE)('<h4 id="_2-配置-1" tabindex="-1"><a class="header-anchor" href="#_2-配置-1" aria-hidden="true">#</a> 2. 配置</h4><blockquote><p>在 <mark>package.json</mark> 中配置 <code>scripts</code> 添加属性</p></blockquote><div class="language-json ext-json"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;prepare&quot;</span><span class="token operator">:</span> <span class="token string">&quot;husky install&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><blockquote><p>新版 husky 提供命令来添加 git 钩子事件 —— <code>husky add &lt;file&gt; [cmd]</code>，即执行下面的命令</p></blockquote><div class="language-bash ext-sh"><pre class="language-bash"><code>npx husky <span class="token function">add</span> .husky/commit-msg <span class="token string">&#39;npx --no-install commitlint --edit &quot;$1&quot;&#39;</span>\nnpx husky <span class="token function">add</span> .husky/pre-push <span class="token string">&quot;npm run test&quot;</span>\n</code></pre></div><ul><li><code>prepare</code> 是 <code>NPM</code> 操作的生命周期的一环，<strong>即</strong>当我们执行 <code>npm install</code> 时会按照生命周期以此触发生命周期钩子，在NPM7：<code>preinstall -&gt; install -&gt; postinstall -&gt; prepublish -&gt; preprepare -&gt; prepare -&gt; postprepare</code></li><li>这里可以发现 <code>commit-msg</code> 和 <code>pre-push</code> 和旧版配置中有点眼熟，这两个恰恰都是我们就是执行git命令<mark>钩子事件名</mark> <a href="#%E5%89%96%E6%9E%90git-hooks">Git Hooks</a></li></ul><h2 id="新版剖析" tabindex="-1"><a class="header-anchor" href="#新版剖析" aria-hidden="true">#</a> 新版剖析</h2><hr><p><mark>git hooks一共有两种方式创建：</mark></p><ol><li>第一种就是旧版的在 <code>.git/hooks</code> 文件夹中创建对应事件名的脚本文件</li><li>第二种就是定义 <code>hooksPath</code> 配置指向 hooks 文件夹</li></ol><h4 id="为什么抛弃传统js的写法" tabindex="-1"><a class="header-anchor" href="#为什么抛弃传统js的写法" aria-hidden="true">#</a> 为什么抛弃传统js的写法</h4><blockquote><p>作者写的文章：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/" target="_blank" rel="noopener noreferrer">链接</a></p></blockquote><ol><li><strong>创建了所有的 <code>git hooks</code></strong> ：旧版正是 git hooks 创建方式的第一种 <ul><li>好处：用户不需要关心 git hooks类型，只需要在 <code>package.json</code> 配置命令即可</li><li>坏处：每次执行 git 操作时所有的 <code>git hooks</code>都会挨个执行</li></ul></li><li><strong>没办法按需引入 <code>git hooks</code></strong>：当用户对 <code>package.json</code> 进行添加操作后，没办法同步添加 <code>.git/hooks</code>对应的钩子文件。</li><li><strong>太局限，用户自定义困难</strong>：比如我有需求在命令行当中利用钩子进行构建，生成文件，读取文件信息等需要大量 <code>shell</code> 命令时，对于一个天天接触 shell 的我而言只能写单一脚本的传统的 <code>package.json</code>写法 太局限了，会很难受。</li></ol><blockquote><p>e.g: 输出一些信息:</p></blockquote><p><img src="https://tva3.sinaimg.cn/large/6ccee0e1gy1gz4gj0f06oj21c20ragvr.jpg" alt="e.g-img"></p><details class="custom-container details"><summary>上图示例代码</summary><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/sh</span>\n<span class="token comment"># 在新版中可以很舒服的写 shell 脚本</span>\n<span class="token builtin class-name">.</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> <span class="token string">&quot;<span class="token variable">$0</span>&quot;</span><span class="token variable">)</span></span>/_/husky.sh&quot;</span>\n\n<span class="token builtin class-name">printf</span> <span class="token string">&quot;<span class="token entity" title="\\n">\\n</span><span class="token entity" title="\\033">\\033</span>[1;32m%s <span class="token entity" title="\\033">\\033</span>[1;33m%s <span class="token entity" title="\\033">\\033</span>[1;32m%s<span class="token entity" title="\\033">\\033</span>[0m<span class="token entity" title="\\n">\\n</span>&quot;</span> <span class="token punctuation">\\</span>\n    <span class="token string">&quot;»»»&quot;</span> <span class="token punctuation">\\</span>\n    <span class="token string">&quot;commitlint checking...&quot;</span> <span class="token punctuation">\\</span>\n    <span class="token string">&quot;«««&quot;</span>\n\n<span class="token function">yarn</span> commitlint --edit <span class="token string">&quot;<span class="token variable">$1</span>&quot;</span>\n</code></pre></div></details><h4 id="新版是什么原理" tabindex="-1"><a class="header-anchor" href="#新版是什么原理" aria-hidden="true">#</a> 新版是什么原理</h4><ol><li>git config 的<code>core.hooksPath</code>。在2016年 <code>git 2.9</code> 版本引入新<a href="https://git-scm.com/docs/githooks#_description" target="_blank" rel="noopener noreferrer">feature</a>，<code>hooksPath</code>属性可以<mark>支持设置 Git Hooks 文件夹指向</mark>。我们可以打开 <code>.git/.config</code>文件看看： <img src="https://tvax3.sinaimg.cn/large/6ccee0e1gy1gz4glcb6tpj21k00e6n1j.jpg" alt="git config"></li><li>新版顺利安装后我们会得到一个文件夹正是<code>.husky</code>：</li></ol><div class="language-bash ext-sh"><pre class="language-bash"><code>$  x <span class="token function">ls</span> -T .husky/ -a\n.husky\n├── _\n│  ├── .gitignore\n│  └── husky.sh\n├── commit-msg\n└── pre-commit\n</code></pre></div><ol start="3"><li>从这里开始他的设计已经明了：<mark>定义了Git Hooks 指向文件夹后，每当我们使用 git 命令的执行时会去对应文件夹下寻找与钩子事件名同名的文件进行source</mark>，这个设计和我们 <a href="https://x-cmd.com/guide/workspace.html" target="_blank" rel="noopener noreferrer">x-cmd</a> 的workspace script设计很像。</li><li>至于新版的commit-msg命令中的 <code>$1</code> 进行输出确认是 <code>.git/COMMIT_EDITMSG</code> 文件： <strong>即</strong>最近一次的commit edit message。</li></ol>',20),p=(0,o.uE)('<h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4><ul><li>其实新版这个设计对于小白添加了一定难度，但是对于项目上的设计放开的局限性。husky的目的也达到了：<strong>作为项目管理上的 git hooks 的入口</strong>。</li><li>立个flag，我相信我们X-Cmd团队会在不远的将来有一套方案和他竞争 😎</li></ul><h2 id="旧版迁移新版" tabindex="-1"><a class="header-anchor" href="#旧版迁移新版" aria-hidden="true">#</a> 旧版迁移新版</h2><hr><ol><li>删除项目当中的 <code>.git/hooks</code> 文件夹、</li><li>删除package.json的 <code>husky</code> 属性</li><li>执行上面新版的<a href="#_7-%E6%96%B0%E7%89%88%E7%8E%A9%E6%B3%95">操作</a></li></ol><h2 id="git-hooks" tabindex="-1"><a class="header-anchor" href="#git-hooks" aria-hidden="true">#</a> Git Hooks</h2><hr><blockquote><p>除了 <code>commit-msg</code> 和 <code>pre-commit</code> 还有什么git hooks ？ <a href="https://git-scm.com/docs/githooks" target="_blank" rel="noopener noreferrer">文档</a></p></blockquote><table><thead><tr><th>Git Hook</th><th>调用时机</th><th>说明</th></tr></thead><tbody><tr><td>pre-applypatch</td><td><code>git am</code>执行前</td><td></td></tr><tr><td>applypatch-msg</td><td><code>git am</code>执行前</td><td></td></tr><tr><td>post-applypatch</td><td><code>git am</code>执行后</td><td>不影响<code>git am</code>的结果</td></tr><tr><td><mark>pre-commit</mark></td><td><code>git commit</code>执行前</td><td>可以用<code>git commit --no-verify</code>绕过</td></tr><tr><td><mark>commit-msg</mark></td><td><code>git commit</code>执行前</td><td>可以用<code>git commit --no-verify</code>绕过</td></tr><tr><td>post-commit</td><td><code>git commit</code>执行后</td><td>不影响<code>git commit</code>的结果</td></tr><tr><td>pre-merge-commit</td><td><code>git merge</code>执行前</td><td>可以用<code>git merge --no-verify</code>绕过。</td></tr><tr><td>prepare-commit-msg</td><td><code>git commit</code>执行后，编辑器打开之前</td><td></td></tr><tr><td>pre-rebase</td><td><code>git rebase</code>执行前</td><td></td></tr><tr><td>post-checkout</td><td><code>git checkout</code>或<code>git switch</code>执行后</td><td>如果不使用<code>--no-checkout</code>参数，则在<code>git clone</code>之后也会执行。</td></tr><tr><td>post-merge</td><td><code>git commit</code>执行后</td><td>在执行<code>git pull</code>时也会被调用</td></tr><tr><td><mark>pre-push</mark></td><td><code>git push</code>执行前</td><td></td></tr><tr><td>pre-receive</td><td><code>git-receive-pack</code>执行前</td><td></td></tr><tr><td>update</td><td></td><td></td></tr><tr><td>post-receive</td><td><code>git-receive-pack</code>执行后</td><td>不影响<code>git-receive-pack</code>的结果</td></tr><tr><td>post-update</td><td>当 <code>git-receive-pack</code>对 <code>git push</code> 作出反应并更新仓库中的引用时</td><td></td></tr><tr><td>...</td><td></td><td></td></tr></tbody></table><br><br><blockquote><p>I just try my best to make thing well, Could you give a <a href="https://github.com/Zhengqbbb/zhengqbbb.github.io" target="_blank" rel="noopener noreferrer">star ⭐</a> to encourage me ?</p></blockquote><blockquote><p>我是 Qbenben，一个爱折腾在沉浸在代码世界打怪升级的深圳小靓仔，感谢您的阅读。<a href="https://github.com/Zhengqbbb" target="_blank" rel="noopener noreferrer">Github</a> · <a href="https://www.qbenben.com/" target="_blank" rel="noopener noreferrer">Blog</a></p></blockquote>',13),h={},u=(0,a(3744).Z)(h,[["render",function(t,e){const a=(0,o.up)("CodeGroupItem"),h=(0,o.up)("CodeGroup"),u=(0,o.up)("Mermaid");return(0,o.wg)(),(0,o.iD)(o.HY,null,[s,(0,o.Wm)(h,null,{default:(0,o.w5)((()=>[(0,o.Wm)(a,{title:"NPM",active:""},{default:(0,o.w5)((()=>[n])),_:1}),(0,o.Wm)(a,{title:"YARN"},{default:(0,o.w5)((()=>[c])),_:1})])),_:1}),i,(0,o.Wm)(h,null,{default:(0,o.w5)((()=>[(0,o.Wm)(a,{title:"NPM",active:""},{default:(0,o.w5)((()=>[d])),_:1}),(0,o.Wm)(a,{title:"YARN"},{default:(0,o.w5)((()=>[r])),_:1})])),_:1}),l,(0,o.Wm)(u,{id:"mermaid_64a56ef0","data-code":'flowchart LR\n    A["git commit"] --\x3eB["git config hooksPath"]\n    B["git config hooksPath"] --\x3eC["To find folder \'.husky\'"]\n    C["To find folder \'.husky\'"] --\x3e D["find \'pre-commit\'"]\n    D["find \'pre-commit\'"] --\x3eE["source \'pre-commit\'"]'}),p],64)}]])}}]);